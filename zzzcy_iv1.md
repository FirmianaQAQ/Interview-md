# 数据库相关

## 基础

### redis 
- redis的简单描述
- redis速度为什么这么快
- 简述一下Redis值的五种类型
- 有序集合的实现方式是哪种数据结构
- 请列举几个用得到Redis的常用使用场景
- Redis怎样防止异常数据不丢失


```
1.Redis就是一种运行速度很快，并发很强的跑在内存上的NoSql数据库，支持键到五种数据类型的映射。

2.采用了多路复用io阻塞机制/数据结构简单，操作节省时间/运行在内存中，自然速度快

3.String 整数，浮点数或者字符串/Set 集合/Zset 有序集合/Hash 散列表/List 列表

4.跳跃表

5.(1)缓存，毫无疑问这是Redis当今最为人熟知的使用场景。再提升服务器性能方面非常有效

  (2)排行榜，在使用传统的关系型数据库（mysql oracle 等）来做这个事儿，非常的麻烦，而利用Redis的SortSet(有序集合)数据结构能够简单的搞定

  (3)计算器/限速器，利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力。限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力

  (4)好友关系，利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能

  (5)简单消息队列，除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦

  (6)Session共享，以PHP为例，默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆。采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息

  (7)一些频繁被访问的数据，经常被访问的数据如果放在关系型数据库，每次查询的开销都会很大，而放在redis中，因为redis 是放在内存中的可以很高效的访问

6.RDB 持久化
  将某个时间点的所有数据都存放到硬盘上。
  可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。
  如果系统发生故障，将会丢失最后一次创建快照之后的数据。
  如果数据量很大，保存快照的时间会很长。
  AOF 持久化
  将写命令添加到 AOF 文件（Append Only File）的末尾。
  使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项:
  选项同步频率always每个写命令都同步everysec每秒同步一次no让操作系统来决定何时同步
  always 选项会严重减低服务器的性能
  everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响
  no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量
  随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。
```

### mysql
- 性能优化
```
表结构优化/索引优化/查询优化

  选取最适用的字段属性
  使用连接（JOIN）来代替子查询(Sub-Queries)
  使用联合(UNION)来代替手动创建的临时表
  事务
  锁定表
  使用外键
  使用索引
  优化的查询语句
```
- 什么是事务
```
事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。
```
- 什么是存储过程？有哪些优缺点
```
存储过程是一些预编译的SQL语句。
  1.更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。
  2.存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全
```
- 索引是什么？有什么作用以及优缺点
```
  索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构

  索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。
  
  MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引
    1、索引加快数据库的检索速度
    2、索引降低了插入、删除、修改等维护任务的速度
    3、唯一索引可以确保每一行数据的唯一性
    4、通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能
    5、索引需要占物理和数据空间

```
## 进阶

### redis
- 讲一下缓存穿透，缓存雪崩以及缓存击穿
- 解决方案

```
1.缓存穿透：就是客户持续向服务器发起对不存在服务器中数据的请求。客户先在Redis中查询，查询不到后去数据库中查询。
  缓存击穿：就是一个很热门的数据，突然失效，大量请求到服务器数据库中
  缓存雪崩：就是大量数据同一时间失效。
2.缓存穿透：
    (1)接口层增加校验，对传参进行个校验，比如说我们的id是从1开始的，那么id<=0的直接拦截；
    (2)缓存中取不到的数据，在数据库中也没有取到，这时可以将key-value对写为key-null，这样可以防止攻击用户反复用同一个id暴力攻击
  缓存击穿：
    最好的办法就是设置热点数据永不过期
  缓存雪崩：
    (1)缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
    (2)如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。
```

### MongoDB

- MongoDB的优缺点及适用场景

```
优势

1. 强大的自动化 shading 功能。

2. 全索引支持，查询非常高效。

3. 面向文档（BSON）存储，数据模式简单而强大。

4. 支持动态查询，查询指令也使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。

5. 支持 javascript 表达式查询，可在服务器端执行任意的 javascript函数。

 
缺点

1. 单个文档大小限制为16M，32位系统上，不支持大于2.5G的数据。

2. 对内存要求比较大，至少要保证热数据（索引，数据及系统其它开销）都能装进内存。

3. 非事务机制，无法保证事件的原子性。

适用场景

1. 适用于实时的插入、更新与查询的需求，并具备应用程序实时数据存储所需的复制及高度伸缩性；

2. 非常适合文档化格式的存储及查询；

3. 高伸缩性的场景：MongoDB 非常适合由数十或者数百台服务器组成的数据库。

4. 对性能的关注超过对功能的要求。
```

### mysql

- 数据库的乐观锁和悲观锁是什么

```
数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。
  悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作
  乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

```

- 事务的4种隔离级别
```
  读未提交(RU)

  读已提交(RC)

  可重复读(RR)

  串行
```
- 事务是如何通过日志来实现的
```
  事务日志是通过redo和innodb的存储引擎日志缓冲（Innodb log buffer）来实现的，当开始一个事务的时候，会记录该事务的lsn(log sequence number)号; 当事务执行时，会往InnoDB存储引擎的日志的日志缓存里面插入事务日志；当事务提交时，必须将存储引擎的日志缓冲写入磁盘（通过innodb_flush_log_at_trx_commit来控制），也就是写数据前，需要先写日志。这种方式称为“预写日志方式”
```

- MySQL中myisam与innodb的区别
```
  InnoDB支持事物，而MyISAM不支持事物
  InnoDB支持行级锁，而MyISAM支持表级锁
  InnoDB支持MVCC, 而MyISAM不支持
  InnoDB支持外键，而MyISAM不支持
  InnoDB不支持全文索引，而MyISAM支持
```
- innodb引擎的4大特性
```
插入缓冲(insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)
```
- Mysql中有哪几种锁


```
MyISAM支持表锁，InnoDB支持表锁和行锁，默认为行锁

表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低

行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高
```